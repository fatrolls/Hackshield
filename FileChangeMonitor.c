/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

unsigned int __stdcall FileChangeMoniterThreadProc(void *Block); // idb
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall FindNextChangeNotification(HANDLE hChangeHandle);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// BOOL __stdcall FindCloseChangeNotification(HANDLE hChangeHandle);
// void __cdecl free(void *Block);
// HANDLE __stdcall FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
// unsigned __int8 *__cdecl _mbsrchr(const unsigned __int8 *String, unsigned int C);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_7; // weak
// extern HMODULE g_hInstLib; idb


//----- (00000000) --------------------------------------------------------
unsigned int __stdcall FileChangeMoniterThreadProc(void *Block)
{
  int (*v1)(void); // eax
  unsigned __int8 *v2; // eax
  HANDLE (__stdcall *v3)(LPCSTR, BOOL, DWORD); // esi
  void (__stdcall *v5)(HANDLE); // esi
  DWORD (__stdcall *v6)(DWORD, const HANDLE *, BOOL, DWORD); // esi
  BOOL (__stdcall *v7)(HANDLE); // edi
  DWORD v8; // eax
  DWORD v9; // eax
  void (__stdcall *v10)(HANDLE); // esi
  HANDLE hChangeHandle; // [esp+Ch] [ebp-21Ch] BYREF
  HANDLE v12; // [esp+10h] [ebp-218h]
  HANDLE hObject; // [esp+14h] [ebp-214h]
  int (*v14)(void); // [esp+18h] [ebp-210h]
  unsigned __int8 String; // [esp+1Ch] [ebp-20Ch] BYREF
  char v16[520]; // [esp+1Dh] [ebp-20Bh] BYREF

  v12 = 0;
  String = 0;
  hChangeHandle = 0;
  hObject = 0;
  memset(v16, 0, sizeof(v16));
  if ( Block && *(_DWORD *)Block && g_hInstLib )
  {
    v1 = GetProcAddress(g_hInstLib, (LPCSTR)&loc_7 + 3);
    v14 = v1;
    if ( v1 && !v1() )
    {
      strcpy((char *)&String, (const char *)Block + 4);
      v2 = _mbsrchr(&String, 0x5Cu);
      v3 = FindFirstChangeNotificationA;
      *v2 = 0;
      hChangeHandle = v3((LPCSTR)&String, 0, 0x13u);
      if ( hChangeHandle != (HANDLE)-1 )
      {
        *_mbsrchr(&String, 0x5Cu) = 0;
        v12 = v3((LPCSTR)&String, 0, 2u);
        if ( v12 == (HANDLE)-1 )
        {
          free(Block);
          FindCloseChangeNotification(hChangeHandle);
          return 0;
        }
        hObject = OpenEventA(0x1F0003u, 0, "{5CF594FA-1219-479b-9D5F-F4FC8744E34F}");
        if ( !hObject )
        {
          free(Block);
          v5 = (void (__stdcall *)(HANDLE))FindCloseChangeNotification;
          FindCloseChangeNotification(hChangeHandle);
          v5(v12);
          return 0;
        }
        v6 = WaitForMultipleObjects;
        v7 = FindNextChangeNotification;
        do
        {
          while ( 1 )
          {
            v8 = v6(3u, &hChangeHandle, 0, 0xFFFFFFFF);
            if ( !v8 )
              break;
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
                goto LABEL_26;
            }
            else
            {
              if ( g_hInstLib )
              {
                if ( v14() )
                  (*(void (__stdcall **)(int, _DWORD, _DWORD))Block)(1793, 0, 0);
              }
              if ( !v7(v12) )
                goto LABEL_26;
            }
          }
          if ( g_hInstLib && v14() )
            (*(void (__stdcall **)(int, _DWORD, _DWORD))Block)(1793, 0, 0);
        }
        while ( v7(hChangeHandle) );
LABEL_26:
        v10 = (void (__stdcall *)(HANDLE))FindCloseChangeNotification;
        FindCloseChangeNotification(hChangeHandle);
        v10(v12);
        CloseHandle(hObject);
      }
    }
    else
    {
      (*(void (__stdcall **)(int, _DWORD, _DWORD))Block)(1793, 0, 0);
    }
    free(Block);
  }
  return 0;
}

// nfuncs=10 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
